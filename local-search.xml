<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/12/11/%E5%85%AC%E5%8F%B8%E5%8A%A0%E5%AF%86%E9%82%AE%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2021/12/11/%E5%85%AC%E5%8F%B8%E5%8A%A0%E5%AF%86%E9%82%AE%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="公司加密邮件结构"><a href="#公司加密邮件结构" class="headerlink" title="公司加密邮件结构"></a>公司加密邮件结构</h3><ul><li>公司加密邮件采用的是双层结构，外部是个pkcs7-envelopdata,内部是个pkcs7-signeddata</li></ul><p>PKCS#7– 数字信封</p><pre><code>EnvelopedData ::= SEQUENCE &#123;   数字信封    version Version,  消息格式版本  缺省值0    recipientInfos RecipientInfos,    接收者集合至少含有一个接收者    encryptedContentInfo EncryptedContentInfo 已加密的内容信息&#125;RecipientInfo ::= SEQUENCE &#123;    version Version, 消息格式版本  缺省值为0    issuerAndSerialNumber IssuerAndSerialNumber,   用于唯一确定接收者证书，其证书签发者DN和证书序列号组成    keyEncryptionAlgorithm  KeyEncryptionAlgorithmIdentifier, 密码算法标识，用于加密密钥    encryptedKey EncryptedKey   被加密的密钥&#125;</code></pre><p>PKCS#7– 数字签名</p><pre><code>SignedData ::= SEQUENCE &#123;    数字签名    version Version,      消息格式版本   缺省值为1    digestAlgorithms DigestAlgorithmIdentifiers,    摘要算法标识集合    contentInfo ContentInfo, 待签名内容    certificates  [0] IMPLICIT ExtendedCertificatesAndCertificates  OPTIONAL,  签名者认证路径中的相关证书    crls   [1] IMPLICIT CertificateRevocationLists OPTIONAL,   CRL集合    signerInfos SignerInfos    签名者信息集合（至少包含一个签名者）&#125;SignerInfo ::= SEQUENCE &#123;     签名者信息格式    version Version,   消息格式版本  缺省值为1    issuerAndSerialNumber IssuerAndSerialNumber,   用于唯一确定签名者证书，由证书签发者DN和证书序列号组成    digestAlgorithm DigestAlgorithmIdentifier,  摘要算法标识，得属于signeddata 中的digestAlgs    authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL,标识签名者用于签名的属性集合    digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier, 用签名者私钥对摘要加密或对签名的公钥算法进行标识    encryptedDigest EncryptedDigest,私钥对摘要进行加密或签名后的值    unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL 表示签名者未用于签名的属性集合   &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>explain学习笔记</title>
    <link href="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>explain 执行计划各列解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- ----------------------------<br>-- Table structure for actor<br>-- ----------------------------<br>DROP TABLE IF EXISTS `actor`;<br>CREATE TABLE `actor` (<br>  `id` int NOT NULL,<br>  `name` varchar(45) DEFAULT NULL,<br>  `update_time` datetime DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;<br><br>-- ----------------------------<br>-- Records of actor<br>-- ----------------------------<br>BEGIN;<br>INSERT INTO `actor` VALUES (1, &#x27;a&#x27;, &#x27;2021-12-08 16:32:09&#x27;);<br>INSERT INTO `actor` VALUES (2, &#x27;b&#x27;, &#x27;2021-12-08 16:32:12&#x27;);<br>INSERT INTO `actor` VALUES (3, &#x27;c&#x27;, &#x27;2021-12-08 16:32:15&#x27;);<br>COMMIT;<br><br>SET FOREIGN_KEY_CHECKS = 1;<br><br>-- ----------------------------<br>-- Table structure for film<br>-- ----------------------------<br>DROP TABLE IF EXISTS `film`;<br>CREATE TABLE `film` (<br>  `id` int NOT NULL AUTO_INCREMENT,<br>  `name` varchar(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `idx_name` (`name`)<br>) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb3;<br><br>-- ----------------------------<br>-- Records of film<br>-- ----------------------------<br>BEGIN;<br>INSERT INTO `film` VALUES (3, &#x27;film0&#x27;);<br>INSERT INTO `film` VALUES (1, &#x27;film1&#x27;);<br>INSERT INTO `film` VALUES (2, &#x27;film2&#x27;);<br>COMMIT;<br><br>SET FOREIGN_KEY_CHECKS = 1;<br><br>-- ----------------------------<br>-- Table structure for film_actor<br>-- ----------------------------<br>DROP TABLE IF EXISTS `film_actor`;<br>CREATE TABLE `film_actor` (<br>  `id` int NOT NULL,<br>  `film_id` int NOT NULL,<br>  `actor_id` int NOT NULL,<br>  `remark` varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `idx_film_actor_id` (`film_id`,`actor_id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;<br><br>-- ----------------------------<br>-- Records of film_actor<br>-- ----------------------------<br>BEGIN;<br>INSERT INTO `film_actor` VALUES (1, 1, 1, NULL);<br>INSERT INTO `film_actor` VALUES (2, 1, 2, NULL);<br>INSERT INTO `film_actor` VALUES (3, 2, 1, NULL);<br>COMMIT;<br><br>SET FOREIGN_KEY_CHECKS = 1;<br><br></code></pre></td></tr></table></figure><ul><li><p>id列</p><ul><li>id列的编号是select的序列号，有几个select就有几个id,并且id的顺序是按select出现的顺序增长的</li><li>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行</li></ul></li><li><p>select_type列</p><ul><li>select_type表示对应行是简单还是复杂的查询<ul><li>simple: 简单查询。查询不包含子查询和union<img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/simple_select.jpg"></li><li>primary: 复杂查询中最外层的select</li><li>subquery：包含在select中的子查询(不在from子句中)</li><li>derived: 包含在from子句中的子查询。mysql会将结果存放到一个临时表中，也称为派生表（derived的英文含义）</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;; #关闭mysql5.7新特性对衍生表的合 并优化 <br>mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;<br>mysql&gt; set session optimizer_switch=&#x27;derived_merge=on&#x27;; #还原默认配置<br></code></pre></td></tr></table></figure>  <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg"><ul><li>union: 在union中的第二个和随后的select</li></ul></li></ul></li></ul><ul><li><p>table 列</p><ul><li><p>表示关联类型或访问类型，即mysql决定如何查找表中的行，查找数据行记录的大概范围</p></li><li><p>依次从最优到最差分别为：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p></li><li><p>一般来说保证查询达到range级别，最好达到ref</p><ul><li><p>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或者索引，例如在索引中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select min(id) from file;<br></code></pre></td></tr></table></figure></li><li><p>const、system: mysql能对查询的某部分进行优化并将其转化为一个常量（可以用show warnings查看结果）用于primary key 或unique key的所有列与常数比较时，所以表最多有一个匹配行，读取一次，速度较快，system是const的特例，表里只有一条元组匹配时为system</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain extended select * from (select * from film where id = 1) tmp;<br>mysql&gt; show warnings;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/const_system.jpg"></p><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/const_system_show_warnings.jpg"></p></li><li><p>eq_ref: primary key或unique key索引的所有部分被连接使用，最多只能返回一条符合条件的记录。这可能是在const之外最好的链接类型了，简单的select查询不会出现这种type.</p> <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> film <span class="hljs-keyword">on</span> film_actor.film_id = film.id;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/eq_ref.jpg"></p></li><li><p>ref: 相比eq_ref,不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合的行</p><ul><li><p>简单select 查询，name是普通索引（非唯一索引）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from film where name = &#x27;film1&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ref_1.jpg"></p></li><li><p>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了左边前缀部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ref_2.jpg"></p></li></ul></li><li><p>range: 范围扫描通常出现在in(),between,&gt;,&lt;,&gt;=等操作中，使用一个索引来检索给定范围的行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from actor where id &gt; 1;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/range.jpg"></p></li><li><p>index：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种索引一般不会从索引数根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些</p> <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.jpg"></p></li><li><p>ALL: 即全表扫描，扫描你的聚簇索引的所有叶子结点。通常情况下这需要增加索引来优化了。</p> <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/all.jpg"></p></li></ul></li></ul></li><li><p>possible_keys</p><ul><li>这一列显示查询可能使用哪些索引来查找</li><li>explain时可能出现possible_keys有列，而key显示NULL的情况，这种情况是因为表中的数据不多，mysql认为索引对此帮助不大，选择了全表扫描</li><li>如果该列为NULL，则没有相关索引，在这种情况下，可以通过检查where子句看是否可以创造一个适当的索引来提高性能</li></ul></li><li><p>key 列</p><ul><li>这一列显示mysql实际采用哪个索引来优化对该表的访问</li><li>如果没有使用，则为NULL。如果想强制mysql使用或者忽视possible_keys列中的索引，在查询中使用force index、ignore index.</li></ul></li><li><p>key_len列</p><ul><li><p>显示mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引的哪些列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from film_actor where film_id = 2;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/key_len.jpg"></p></li><li><p>计算规则如下</p><ul><li>字符串：char(n)和varchar(n),5.0.3版本后，n代表字符数，而不是字节数，如果是utf-8，一个数字或一个字母占1个字节，一个汉字占3个字节<ul><li>char(n)：如果存汉字长度就是3n字节</li><li>varchar(n)：如果存汉字则长度就是3n+2字节，加的2字节用来存储字符串长度，因为varchar是变长字符串</li></ul></li><li>数值类型<ul><li>tinyint: 1字节</li><li>smallint: 2字节</li><li>int: 4字节</li><li>bigint: 8字节</li></ul></li><li>时间类型<ul><li>date: 3字节</li><li>timestamp: 4字节</li><li>datetime: 8字节</li></ul></li><li>如果字段允许为NULL，需要一字节记录是否为NULL</li><li>索引最大长度是768字节，当字符串长度过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</li></ul></li></ul></li><li><p>ref列</p></li></ul><ul><li>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const(常量),字段名（film.id）</li></ul><ul><li><p>rows列</p><ul><li>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数</li></ul></li><li><p>extra列</p><ul><li><p>Using index: 使用覆盖索引</p><ul><li><p>覆盖索引定义：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；</p></li><li><p>覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树获取其它字段值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select film_id from film_actor where film_id = 1;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_index.jpg"></p></li></ul></li><li><p>Using where: 使用where 语句来处理结果，并且查询的列未被索引覆盖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from actor where name = &#x27;a&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_where.jpg"></p></li><li><p>Using index condition: 查询的列不完全被索引覆盖，where条件中是一个前导列的范围</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> film_id &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_index_condition.jpg"></p></li><li><p>Using temporary: mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化，首先是想到索引来优化</p><ul><li><p>actor.name没有索引，此时创建了张临时表来distinct</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select distinct name from actor;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_temporary_1.jpg"></p></li><li><p>film.name建立了idx_name索引，此时查询时extra是using index，没有用临时表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select distinct name from film;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_temporary_2.jpg"></p></li></ul></li><li><p>Using filesort: 将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况一般也是要用索引来优化</p><ul><li><p>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id,然后排序name并检索记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from actor order by name;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_filesort_1.jpg"></p></li><li><p>film.name建立了idx_name索引，此时查询时extra是using index</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from film order by name;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_filesort_2.jpg"></p></li></ul></li><li><p>Select tables optimized away：使用某些聚合函数（比如max,min）来访问存在索引的某个字段时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select min(id) from film;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/select_tables_optimized_away.jpg"></p></li></ul></li></ul><p>​             </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字证书基础详解</title>
    <link href="/2021/12/08/%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%89%A9%E5%B1%95%E9%A1%B9%E7%94%A8%E9%80%94/"/>
    <url>/2021/12/08/%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%89%A9%E5%B1%95%E9%A1%B9%E7%94%A8%E9%80%94/</url>
    
    <content type="html"><![CDATA[<h2 id="证书结构以及常见扩展项用途"><a href="#证书结构以及常见扩展项用途" class="headerlink" title="证书结构以及常见扩展项用途"></a>证书结构以及常见扩展项用途</h2><h3 id="证书结构"><a href="#证书结构" class="headerlink" title="证书结构"></a>证书结构</h3><p>Certificate ::= SEQUENCE {</p><pre><code>    tbsCertificate       TBSCertificate, -- 证书主体    signatureAlgorithm   AlgorithmIdentifier, -- 证书签名算法标识    signatureValue       BIT STRING --证书签名值,是使用signatureAlgorithm部分指定的签名算法对tbsCertificate证书主题部分签名后的值.     &#125;</code></pre><p>   TBSCertificate ::= SEQUENCE {</p><pre><code>    version         [0] EXPLICIT Version DEFAULT v1, -- 证书版本号    serialNumber         CertificateSerialNumber, -- 证书序列号，对同一CA所颁发的证书，序列号唯一标识证书    signature            AlgorithmIdentifier, --证书签名算法标识    issuer               Name,                --证书发行者名称    validity             Validity,            --证书有效期    subject              Name,                --证书主体名称    subjectPublicKeyInfo SubjectPublicKeyInfo,--证书公钥    issuerUniqueID [1] IMPLICIT UniqueIdentifier OPTIONAL,                         -- 证书发行者ID(可选)，只在证书版本2、3中才有    subjectUniqueID [2] IMPLICIT UniqueIdentifier OPTIONAL,                         -- 证书主体ID(可选)，只在证书版本2、3中才有    extensions      [3] EXPLICIT Extensions OPTIONAL                         -- 证书扩展段（可选），只在证书版本3中才有    &#125;</code></pre><p>   Version ::= INTEGER { v1(0), v2(1), v3(2) }</p><p>   CertificateSerialNumber ::= INTEGER</p><p>   AlgorithmIdentifier ::= SEQUENCE {</p><pre><code>    algorithm               OBJECT IDENTIFIER,    parameters              ANY DEFINED BY algorithm OPTIONAL &#125;</code></pre><p>   parameters:</p><p>   Dss-Parms ::= SEQUENCE { – parameters ，DSA(DSS)算法时的parameters,</p><p>RSA算法没有此参数</p><pre><code>    p             INTEGER,    q             INTEGER,    g             INTEGER &#125;</code></pre><p>signatureValue：</p><p>Dss-Sig-Value ::= SEQUENCE { – sha1DSA签名算法时,签名值</p><pre><code>                  r       INTEGER,                  s       INTEGER &#125;</code></pre><p>   Name ::= CHOICE {</p><pre><code> RDNSequence &#125;</code></pre><p>   RDNSequence ::= SEQUENCE OF RelativeDistinguishedName</p><p>   RelativeDistinguishedName ::=</p><pre><code> SET OF AttributeTypeAndValue</code></pre><p>   AttributeTypeAndValue ::= SEQUENCE {</p><pre><code> type     AttributeType, value    AttributeValue &#125;</code></pre><p>   AttributeType ::= OBJECT IDENTIFIER</p><p>   AttributeValue ::= ANY DEFINED BY AttributeType</p><p>   Validity ::= SEQUENCE {</p><pre><code>    notBefore      Time,  -- 证书有效期起始时间    notAfter       Time  -- 证书有效期终止时间    &#125;</code></pre><p>   Time ::= CHOICE {</p><pre><code>    utcTime        UTCTime,    generalTime    GeneralizedTime &#125;</code></pre><p>   UniqueIdentifier ::= BIT STRING</p><p>   SubjectPublicKeyInfo ::= SEQUENCE {</p><pre><code>    algorithm            AlgorithmIdentifier, -- 公钥算法    subjectPublicKey     BIT STRING            -- 公钥值    &#125;</code></pre><p>subjectPublicKey:</p><p>RSAPublicKey ::= SEQUENCE { – RSA算法时的公钥值</p><pre><code>     modulus            INTEGER, -- n     publicExponent     INTEGER -- e -- &#125;</code></pre><p>   Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension</p><p>   Extension ::= SEQUENCE {</p><pre><code>    extnID      OBJECT IDENTIFIER,    critical    BOOLEAN DEFAULT FALSE,    extnValue   OCTET STRING &#125;</code></pre><h4 id="常见扩展项用途—RFC3280"><a href="#常见扩展项用途—RFC3280" class="headerlink" title="常见扩展项用途—RFC3280"></a>常见扩展项用途—RFC3280</h4><ul><li>authorityKeyIdentifier（证书签发者密钥标识）<ul><li>authorityKeyIdentifier扩展项用于区分证书签发者（CA）的公钥。当证书签发者拥有多个公私钥对用于签发用户证书时，必须使用该扩展项</li><li>该扩展项必须设置为非关键项（critical=FALSE）</li></ul></li></ul><p>authorityKeyIdentifier格式用ASN.1描述如下</p><p>   id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::= {id-ce 35}</p><p>   authorityKeyIdentifier ::= SEQUENCE{</p><pre><code>         keyIdentifier                [0]KeyIdentifier              OPTIONAL,         authorityCertIssuer          [1]GeneralNames               OPTIONAL,         authorityCertSerialNumber    [2]CertificateSerialNumber    OPTIONAL</code></pre><p>   }<br>   KeyIdentifier::=OCTET STRING</p><p>authorityKeyIdentifier基于证书签发者证书（CA证书）中的内容生成，主要有两种生成方式：基于subjectKeyIdetifier,以及基于issur和serialNumber。当基于subjectKeyIdentifier生成时，keyIdentifier通常等于证书签发者证书中的subjectKeyIdentifier。</p><ul><li>subjectKeyIdentifier（证书持有者密钥标识）<ul><li>该扩展项用于区分证书持有者的公钥</li><li>该扩展项必须设置为关键项（critical=TRUE）</li><li>也可以使用递增的证书来表示</li></ul></li></ul><p>subjectKeyIdentifier格式用ASN.1描述如下</p><p>   id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::= {id-ce 14}</p><p>   SubjectKeyIdentifier ::= Key</p><p>subjectKeyIdentifier可以基于公钥产生，两种常用的产生方法如下：</p><p>1）将subjectPublicKey删除标识（tag）、长度（length）和无数比特个数（number of unused bits后）,使用sha1算法计算获得160比特摘要值。subjectKeyIdentifier=160比特摘要值。<br>2）同方法1计算获得160比特摘要值。subjectKeyIdentifier=4 比特类型（‘0100’）+至少80比特摘要值</p><ul><li>keyUsage<ul><li>keyUsage扩展项用于定义证书中的公钥及其对应私钥的用途。当需要限制或约束密钥只能用于部分操作时，可以使用该扩展项。</li><li>该扩展项必须设置为关键项（critical=TRUE）</li></ul></li></ul><p>keyUsage格式用ASN.1描述如下</p><p>   id-ce-keyUsage OBJECT IDENTIFIER ::= {id-ce 15}</p><p>   keyUsage ::= BIT STRING{</p><pre><code>         digitalSignature             (0),         nonRepudiation               (1),         keyEncipherMent              (2),         dataEncipherment             (3),         keyAgreement                 (4),         keyCertSign                  (5),         cRLSign                      (6),         encipherOnly                 (7),         decipherOnly                 (8)</code></pre><p>   }<br>1）digitalSignature表示数字签名服务，可用于实体身份认证和数据完整性认证，但不可用于签发证书和CRL<br>2）nonRepudiation表示抗抵赖服务，可用于操作或交易的抗抵赖，但不可用于证书和CRL签发行为的抗抵赖<br>3）keyEncipherment用于密钥加密。当RSA密钥用于密钥管理时，需要将keyUsage设置为keyEncipherment<br>4）dataEncipherment用于数据加密，但不可用于密钥加密<br>5）keyAgreement用于密钥协商。如使用DH算法密钥进行密钥管理<br>5）keyCertSign用于签发和验证数字证书。当KeyUsage设置为keyCertSign时，需同时设置扩展项basicConstriants-&gt;cA=TRUE<br>6）cRLSign用于签发和验证CRL（包括CRL、增量CRL、ARL等）<br>7）encipherOnly表示只用于数据加密。仅当keyAgreement设置时，encipherOnly才有效，表示密钥只用于密钥协商过程中的数据加密<br>8）decipherOnly表示只用于数据解密。仅当keyAgreement设置时，decipherOnly才有效，表示密钥只用于密钥协商过程中的数据解密</p><ul><li>privateKeyUsagePeriod(私钥有效期)<ul><li>用于定义私钥有效期，允许私钥有效期不同于证书有效期，主要用于限制签名密钥，即与证书对应的私钥不允许在私钥有效期之外进行数字签名操作</li><li>该扩展项必须设置为非关键项（critical=FALSE）</li></ul></li></ul><p>privateKeyUsagePeriod格式用ASN.1描述如下：</p><p>   id-ce-privateKeyUsagePeriod OBJECT IDENTIFIER ::= {id-ce 16}</p><p>   privateKeyUsagePeriod ::= SEQUENCE {</p><pre><code>         notBefore       [0]      GeneralizedTime   OPTIONAL,         notAfter        [1]      GeneralizedTime   OPTIONAL</code></pre><p>   }</p><ul><li>basicConstraints（基本限制）<ul><li>basicConstraints扩展项用于区分证书持有者是否是CA。如果是CA则限制其认证路径的最大长度</li><li>当用于终端实体证书时，该扩展项可以设置为关键项或非关键项。当用于签发用户证书的CA证书时，该扩展项必须设置为关键项，当CA证书不用于签发用户证书，只用于签发CRL时，该扩展项可以设置为关键项或非关键项。</li></ul></li></ul><p>basicContraints格式用ASN.1描述如下</p><p>   id-ce-basicConstraints OBJECT IDENTIFIER ::= {id-ce 19}</p><p>   basicConstraints ::= SEQUENCE {</p><pre><code>   cA               BOOLEAN DEFAULT FALSE,   pathConstraint   INTEGER(0..MAX)OPTIONAL</code></pre><p>   }<br>其中，cA表示该证书是否是CA，如果设置为FALSE，则keyUsage扩展项不能包含keyCertSign;如果设置为TRUE，而且keyUsage扩展项包含keyCertSign时，pathConstraint才有效，表示该CA证书之后认证路径中非自签名CA证书的最大数目。pathConstraint出现时必要大于或等于0，当等于0的时候表示该CA证书不能签发下级CA证书，只能签发终端实体证书，如果pathConstraint没出现，表明认证路径的长度没有限制</p><ul><li>extendedKeyUsage（扩展密钥用途）<ul><li>extendedKeyUsage扩展项用于表示证书中公钥及其对应私钥的一个或多个用途，是keyUsage扩展项基本用途或补充。通常，该扩展项只用于终端实体证书</li><li>该扩展项可以设置为关键项或非关键项，由证书签发者决定。当设置为anyExtendedKeyUsage时，该扩展项应该设置为非关键项</li></ul></li></ul><p>extendedKeyUsage格式用ASN.1描述如下</p><p>   id-ce-extendedKeyUsage OBJECT IDENTIFIER ::= {id-ce 37}<br>   ExtKeyUsageSyntax ::=SEQUENCE SIZE(1..MAX) OF KeyPurposeId<br>   KeyPurposedId ::= OBJECT IDENTIFIER</p><p>当keyUsage和extendedKeyUsage同时存在时，必须分别进行处理，该证书只能用于keyUsage和extendedKeyUsage同时允许的用途，如果KeyUsage和extendedKeyUsage所定义的用途完全互斥，没有同时允许的用途，则该证书被认为无效，不能用于任何目的</p><p>常见的扩展密钥用途用ASN.1描述如下：<br>   anyExtendedKeyUsage OBJECT IDENTIFIER ::= {id-ce-extKeyUsage 0}</p><pre><code>         id-kp OBJECT IDENTIFIER ::= &#123;id-pkix 3&#125;         id-kp-serverAuth           OBJECT IDENTIFIER ::=&#123;id-kp 1&#125;         id-kp-clientAuth           OBJECT IDENTIFIER ::=&#123;id-kp 2&#125;         id-kp-codeSigning          OBJECT IDENTIFIER ::=&#123;id-kp 3&#125;         id-kp-emailProtection      OBJECT IDENTIFIER ::=&#123;id-kp 4&#125;         id-kp-timeStamping         OBJECT IDENTIFIER ::=&#123;id-kp 8&#125;         id-kp-OCSPSigning          OBJECT IDENTIFIER ::=&#123;id-kp 9&#125;</code></pre><p>   }</p><p>其中，anyExtendedKeyUsage表示所有用途。id-kp-serverAuth表示Web服务器SSL/TLS身份认证，等同于keyUsage中的digitalSignature、keyEncipherment、keyAgreement。id-kp-clientAuth表示Web服务器SSL/TLS身份认证，等同于keyUsage中的digitalSignature、keyAgreement。id-kp-codeSigning表示可执行的代码签名，等同于keyUsage中的digitalSignature。id-kp-emailProtection表示电子邮件保护，等同于KeyUsage的digitalSignature、nonRepudiation、keyEncipherment或keyAgreement。id-kp-timestamping表示时间戳，即将某对象摘要值与时间绑定，等同于keyUsage中的digitalSignature、nonRepudiation.id-kp-OCSPSigning表示OCSP响应包签名，等同于keyUsage中的digitalSignature.nonRepudiation。</p><ul><li>cRLDistributionPoints()<ul><li>cRLDistributionPoints用于确定如何获得CRL信息</li><li>cRLDistributionPoints应该设置为非关键项</li></ul></li></ul><p>cRLDistributionPoints格式用ASN.1描述如下：</p><p>   id-ce-cRLDistributionPoints OBJECT IDENTIFIER ::= {id-ce 31}</p><p>   cRLDistributionPoints ::=SEQUENCE SIZE(1..MAX)OF DistributionPoint</p><p>   DistributionPoint ::=SEQUENCE{</p><pre><code>         distributionPoint          [0]       DistributionPointName OPTIONAL,         reasons                    [1]       ReasonFlags    OPTIONAL,         cRLIssuer                  [2]       GeneralNames   OPTIONAL</code></pre><p>   }</p><p>   DistributionPointName ::= CHOICE{</p><pre><code>         fullName                   [0]          GeneralNames,         nameRelativeToCRLIssuer    [1]          RelativeDistributionPointName</code></pre><p>   }</p><p>   ReasonFlags ::= BIT STRING{</p><pre><code>   unused                     (0),   keyCompromise              (1),            --表示密钥泄露   cACompromise               (2),            --表示CA泄露   affiliationChanged         (3),            --表示关系变更   superseded                 (4),            --表示废弃   cessationOfOperation       (5),            --表示操作终止   certificateHold            (6),            --表示证书冻结   privilegeWithdrawn         (7),            --表示权限撤销   aACompromise               (8),            --表示AA泄露</code></pre><p>   }</p><p>其中，DistributionPoint类型不能只包含reasons字段，distributionPoint和cRLIssuer字段至少包含一个。如果证书签发者不是CRL签发者，则cRLIssuer字段必须存在，而且必须包含CRL签发者的DN名称。如果证书签发者也是CRL签发者，则cRLIssuer字段必须忽略，distributionPoint字段必须存在.<br>distributionPoint定义为DistributionPointName类型。如果distributionPoint包含多个名称值，则每个名称表示一种方法或机制，不同方法或机制能获取相同的CRL，如LDAP和HTTP。如果distributionPoint只包含单个值（nameRelativeToCRLIssuer），则表示DN项的一部分；只需将其附加到CRL签发者或证书签发者的X.500名称后即可获得CRL发布点名称；如果DistributionPoint中的cRLIssuer存在，则使用CRL签发者cRLIssuer，否则使用证书签发者。</p>]]></content>
    
    
    <categories>
      
      <category>pki</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pki</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arthas技巧</title>
    <link href="/2021/12/07/Arthas%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/12/07/Arthas%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul><li>dashboard<ul><li>-i 实时数据的时间间隔，默认5000ms,</li><li>-n 刷新实时数据的次数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dashboard -i 5000 -n 20<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li>thread <ul><li>-n 指定最忙的前N个线程并打印堆栈</li><li>-b 找出当前线程阻塞其他线程的线程</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">thread -n 3<br>thread -b<br>thread 51<br></code></pre></td></tr></table></figure><ul><li><p>jvm(查看jvm参数)</p></li><li><p>sysprop(当前jvm的系统属性)</p></li><li><p>sysenv(当前jvm的环境属性)</p></li><li><p>vmoption(查看，更新jvm诊断相关的参数)</p></li><li><p>perfcounter(查看当前jvm的Perf Counter信息)</p></li><li><p>logger(查看该进程下的logger相关信息)</p><ul><li>更新日志级别<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">logger -n kl --level debug<br></code></pre></td></tr></table></figure></li></ul></li><li><p>mbean</p></li><li><p>getstatic(查看类的静态属性,支持ognl表达式)</p></li><li><p>ognl(<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;<br>@ArrayList[<br>    @String[/opt/java/8.0.181-zulu/jre],<br>    @String[OpenJDK Runtime Environment],<br>]<br></code></pre></td></tr></table></figure></li><li><p>sc(查看已加载的类信息)</p><ul><li>-d 输出当前类的详细信息</li><li>-f 输出当前类的成员变量信息</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sc -d -f kl.cdsm2.web.MainApp<br></code></pre></td></tr></table></figure><ul><li>sm(查看已加载类的方法信息)<ul><li>-d 展示每个方法的详细信息</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sm -d kl.cdsm2.web.MainApp [init]<br></code></pre></td></tr></table></figure><ul><li>dump(已加载的bytecode 到指定目录)</li><li>heapdump(类似于jmap的heap dump功能)</li><li>vmtool(采用JVMTI接口查看内存对象，强制GC)<ul><li>JVMTI接口（<a href="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html%EF%BC%89">https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html）</a></li><li>–action 后接需要指定的命令</li><li>getInstances (-x/–expand) </li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vmtool --action getInstances --className kl.cdsm2.config.ApiServiceCfg -x 3<br></code></pre></td></tr></table></figure><ul><li><p>jad(反编译指定已加载类的源码)</p></li><li><p>classloader(查看类加载信息)</p><ul><li>–load 使用类加载去加载类信息</li><li>-t 查看继承树</li><li>-c 查看URLClassloader实际的urls</li></ul></li><li><p>mc (编译.java 文件生成.class)</p></li><li><p>retransform/redefine(加载外部的.class文件，retransform/redefine jvm已加载的类)</p><ul><li>不允许新增加field/method</li><li>正在跑的函数，没有退出不能生效。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">结合 jad/mc 命令使用<br>jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java<br> <br>mc /tmp/UserController.java -d /tmp<br> <br>retransform /tmp/com/example/demo/arthas/user/UserController.class<br><br>使用mc命令来编译jad的反编译的代码有可能失败。可以在本地修改代码，编译好后再上传到服务器上。有的服务器不允许直接上传文件，可以使用base64命令来绕过。<br><br>在本地先转换.class文件为base64，再保存为result.txt<br><br>base64 &lt; Test.class &gt; result.txt<br>到服务器上，新建并编辑result.txt，复制本地的内容，粘贴再保存<br><br>把服务器上的 result.txt还原为.class<br><br>base64 -d &lt; result.txt &gt; Test.class<br>用md5命令计算哈希值，校验是否一致<br></code></pre></td></tr></table></figure><ul><li><p>monitor(方法执行监控)</p><ul><li>-c 统计周期，默认值为120秒</li></ul></li><li><p>watch(函数执行数据观测)</p><ul><li>-b 函数调用之前观察</li><li>-f 函数调用之后观察</li><li>-s 函数返回之后观察</li><li>-e 函数异常之后观察</li><li>-x 函数深度</li></ul></li><li><p>trace（方法内部调用路径,并输出方法路径上的每个节点上耗时）渲染和统计整个调用链路上的所有性能开销和追踪调用链路</p><ul><li>-n 次数</li><li>–skipJDKMethod false default true</li><li>‘#cost &gt; 10’展示耗时大于10ms的调用路径，有利于排查问题</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">trace kl.cdsm2.service.apisvr.biz.cert.CertIssueApplyHandler handleBiz<br>trace kl.cdsm2.service.apisvr.biz.cert.CertIssueApplyHandler handleBiz &#x27;#cost&gt;10&#x27;<br></code></pre></td></tr></table></figure><ul><li>stack(输出当前方法被调用的调用路径)，使用方法通trace</li><li>tt（方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调进行观测，timetunnel）<ul><li>-t 记录方法每次的指定情况</li><li>-n 3 当你执行一个调用量不高的方法可能你还能有足够的时间用ctrl C 中断，如果遇到调用量非常大的方法，瞬间就把你的JVM内存撑爆。</li><li>-l 查看时空隧道，检索调用记录</li><li>-i index 编号 查看详细信息</li><li>-p 重做一次调用</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tt -t kl.cdsm2.service.apisvr.biz.cert.CertIssueApplyHandler handleBiz<br>tt -l<br>tt -s &#x27;method.name==&quot;handleBiz&quot;&#x27;<br>tt -i 1000 -p<br></code></pre></td></tr></table></figure><ul><li>profiler 支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集的采样结果生成火焰图</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">profiler start<br>profiler status<br>profiler stop --format html<br></code></pre></td></tr></table></figure><ul><li>base64</li><li>tee</li><li>auth</li></ul>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引与数据结构</title>
    <link href="/2021/12/07/mysql%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/12/07/mysql%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是帮助mysql高效获取数据的排好序的数据结构。</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
