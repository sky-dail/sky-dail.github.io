<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>explain学习笔记</title>
    <link href="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="explain-执行计划各列解析"><a href="#explain-执行计划各列解析" class="headerlink" title="explain 执行计划各列解析"></a>explain 执行计划各列解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- ----------------------------<br>-- Table structure for actor<br>-- ----------------------------<br>DROP TABLE IF EXISTS `actor`;<br>CREATE TABLE `actor` (<br>  `id` int NOT NULL,<br>  `name` varchar(45) DEFAULT NULL,<br>  `update_time` datetime DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;<br><br>-- ----------------------------<br>-- Records of actor<br>-- ----------------------------<br>BEGIN;<br>INSERT INTO `actor` VALUES (1, &#x27;a&#x27;, &#x27;2021-12-08 16:32:09&#x27;);<br>INSERT INTO `actor` VALUES (2, &#x27;b&#x27;, &#x27;2021-12-08 16:32:12&#x27;);<br>INSERT INTO `actor` VALUES (3, &#x27;c&#x27;, &#x27;2021-12-08 16:32:15&#x27;);<br>COMMIT;<br><br>SET FOREIGN_KEY_CHECKS = 1;<br><br>-- ----------------------------<br>-- Table structure for film<br>-- ----------------------------<br>DROP TABLE IF EXISTS `film`;<br>CREATE TABLE `film` (<br>  `id` int NOT NULL AUTO_INCREMENT,<br>  `name` varchar(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `idx_name` (`name`)<br>) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb3;<br><br>-- ----------------------------<br>-- Records of film<br>-- ----------------------------<br>BEGIN;<br>INSERT INTO `film` VALUES (3, &#x27;film0&#x27;);<br>INSERT INTO `film` VALUES (1, &#x27;film1&#x27;);<br>INSERT INTO `film` VALUES (2, &#x27;film2&#x27;);<br>COMMIT;<br><br>SET FOREIGN_KEY_CHECKS = 1;<br><br>-- ----------------------------<br>-- Table structure for film_actor<br>-- ----------------------------<br>DROP TABLE IF EXISTS `film_actor`;<br>CREATE TABLE `film_actor` (<br>  `id` int NOT NULL,<br>  `film_id` int NOT NULL,<br>  `actor_id` int NOT NULL,<br>  `remark` varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `idx_film_actor_id` (`film_id`,`actor_id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;<br><br>-- ----------------------------<br>-- Records of film_actor<br>-- ----------------------------<br>BEGIN;<br>INSERT INTO `film_actor` VALUES (1, 1, 1, NULL);<br>INSERT INTO `film_actor` VALUES (2, 1, 2, NULL);<br>INSERT INTO `film_actor` VALUES (3, 2, 1, NULL);<br>COMMIT;<br><br>SET FOREIGN_KEY_CHECKS = 1;<br><br></code></pre></td></tr></table></figure><ul><li><p>id列</p><ul><li>id列的编号是select的序列号，有几个select就有几个id,并且id的顺序是按select出现的顺序增长的</li><li>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行</li></ul></li><li><p>select_type列</p><ul><li>select_type表示对应行是简单还是复杂的查询<ul><li>simple: 简单查询。查询不包含子查询和union<img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/simple_select.jpg"></li><li>primary: 复杂查询中最外层的select</li><li>subquery：包含在select中的子查询(不在from子句中)</li><li>derived: 包含在from子句中的子查询。mysql会将结果存放到一个临时表中，也称为派生表（derived的英文含义）</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;; #关闭mysql5.7新特性对衍生表的合 并优化 <br>mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;<br>mysql&gt; set session optimizer_switch=&#x27;derived_merge=on&#x27;; #还原默认配置<br></code></pre></td></tr></table></figure><pre><code>![](select_type_1.jpg)</code></pre><ul><li>union: 在union中的第二个和随后的select</li></ul></li></ul></li></ul><ul><li><p>table 列</p><ul><li><p>表示关联类型或访问类型，即mysql决定如何查找表中的行，查找数据行记录的大概范围</p></li><li><p>依次从最优到最差分别为：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p></li><li><p>一般来说保证查询达到range级别，最好达到ref</p><ul><li><p>NULL：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或者索引，例如在索引中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select min(id) from file;<br></code></pre></td></tr></table></figure></li><li><p>const、system: mysql能对查询的某部分进行优化并将其转化为一个常量（可以用show warnings查看结果）用于primary key 或unique key的所有列与常数比较时，所以表最多有一个匹配行，读取一次，速度较快，system是const的特例，表里只有一条元组匹配时为system</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain extended select * from (select * from film where id = 1) tmp;<br>mysql&gt; show warnings;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/const_system.jpg"></p><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/const_system_show_warnings.jpg"></p></li><li><p>eq_ref: primary key或unique key索引的所有部分被连接使用，最多只能返回一条符合条件的记录。这可能是在const之外最好的链接类型了，简单的select查询不会出现这种type.</p> <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> film <span class="hljs-keyword">on</span> film_actor.film_id = film.id;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/eq_ref.jpg"></p></li><li><p>ref: 相比eq_ref,不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合的行</p><ul><li><p>简单select 查询，name是普通索引（非唯一索引）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from film where name = &#x27;film1&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ref_1.jpg"></p></li><li><p>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了左边前缀部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ref_2.jpg"></p></li></ul></li><li><p>range: 范围扫描通常出现在in(),between,&gt;,&lt;,&gt;=等操作中，使用一个索引来检索给定范围的行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from actor where id &gt; 1;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/range.jpg"></p></li><li><p>index：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种索引一般不会从索引数根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些</p> <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> film;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.jpg"></p></li><li><p>ALL: 即全表扫描，扫描你的聚簇索引的所有叶子结点。通常情况下这需要增加索引来优化了。</p> <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> actor;<br></code></pre></td></tr></table></figure><p> <img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/all.jpg"></p></li></ul></li></ul></li><li><p>possible_keys</p><ul><li>这一列显示查询可能使用哪些索引来查找</li><li>explain时可能出现possible_keys有列，而key显示NULL的情况，这种情况是因为表中的数据不多，mysql认为索引对此帮助不大，选择了全表扫描</li><li>如果该列为NULL，则没有相关索引，在这种情况下，可以通过检查where子句看是否可以创造一个适当的索引来提高性能</li></ul></li><li><p>key 列</p><ul><li>这一列显示mysql实际采用哪个索引来优化对该表的访问</li><li>如果没有使用，则为NULL。如果想强制mysql使用或者忽视possible_keys列中的索引，在查询中使用force index、ignore index.</li></ul></li><li><p>key_len列</p><ul><li><p>显示mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引的哪些列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from film_actor where film_id = 2;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/key_len.jpg"></p></li><li><p>计算规则如下</p><ul><li>字符串：char(n)和varchar(n),5.0.3版本后，n代表字符数，而不是字节数，如果是utf-8，一个数字或一个字母占1个字节，一个汉字占3个字节<ul><li>char(n)：如果存汉字长度就是3n字节</li><li>varchar(n)：如果存汉字则长度就是3n+2字节，加的2字节用来存储字符串长度，因为varchar是变长字符串</li></ul></li><li>数值类型<ul><li>tinyint: 1字节</li><li>smallint: 2字节</li><li>int: 4字节</li><li>bigint: 8字节</li></ul></li><li>时间类型<ul><li>date: 3字节</li><li>timestamp: 4字节</li><li>datetime: 8字节</li></ul></li><li>如果字段允许为NULL，需要一字节记录是否为NULL</li><li>索引最大长度是768字节，当字符串长度过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</li></ul></li></ul></li><li><p>ref列</p></li></ul><ul><li>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const(常量),字段名（film.id）</li></ul><ul><li><p>rows列</p><ul><li>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数</li></ul></li><li><p>extra列</p><ul><li><p>Using index: 使用覆盖索引</p><ul><li><p>覆盖索引定义：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；</p></li><li><p>覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树获取其它字段值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select film_id from film_actor where film_id = 1;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_index.jpg"></p></li></ul></li><li><p>Using where: 使用where 语句来处理结果，并且查询的列未被索引覆盖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from actor where name = &#x27;a&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_where.jpg"></p></li><li><p>Using index condition: 查询的列不完全被索引覆盖，where条件中是一个前导列的范围</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> film_actor <span class="hljs-keyword">where</span> film_id &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_index_condition.jpg"></p></li><li><p>Using temporary: mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化，首先是想到索引来优化</p><ul><li><p>actor.name没有索引，此时创建了张临时表来distinct</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select distinct name from actor;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_temporary_1.jpg"></p></li><li><p>film.name建立了idx_name索引，此时查询时extra是using index，没有用临时表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select distinct name from film;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_temporary_2.jpg"></p></li></ul></li><li><p>Using filesort: 将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况一般也是要用索引来优化</p><ul><li><p>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id,然后排序name并检索记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from actor order by name;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_filesort_1.jpg"></p></li><li><p>film.name建立了idx_name索引，此时查询时extra是using index</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from film order by name;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/using_filesort_2.jpg"></p></li></ul></li><li><p>Select tables optimized away：使用某些聚合函数（比如max,min）来访问存在索引的某个字段时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select min(id) from film;<br></code></pre></td></tr></table></figure><p><img src="/2021/12/11/explain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/select_tables_optimized_away.jpg"></p></li></ul></li></ul><p>​             </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arthas技巧</title>
    <link href="/2021/12/07/Arthas%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/12/07/Arthas%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul><li>dashboard<ul><li>-i 实时数据的时间间隔，默认5000ms,</li><li>-n 刷新实时数据的次数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dashboard -i 5000 -n 20<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li>thread <ul><li>-n 指定最忙的前N个线程并打印堆栈</li><li>-b 找出当前线程阻塞其他线程的线程</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">thread -n 3<br>thread -b<br>thread 51<br></code></pre></td></tr></table></figure><ul><li><p>jvm(查看jvm参数)</p></li><li><p>sysprop(当前jvm的系统属性)</p></li><li><p>sysenv(当前jvm的环境属性)</p></li><li><p>vmoption(查看，更新jvm诊断相关的参数)</p></li><li><p>perfcounter(查看当前jvm的Perf Counter信息)</p></li><li><p>logger(查看该进程下的logger相关信息)</p><ul><li>更新日志级别<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">logger -n kl --level debug<br></code></pre></td></tr></table></figure></li></ul></li><li><p>mbean</p></li><li><p>getstatic(查看类的静态属性,支持ognl表达式)</p></li><li><p>ognl(<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;<br>@ArrayList[<br>    @String[/opt/java/8.0.181-zulu/jre],<br>    @String[OpenJDK Runtime Environment],<br>]<br></code></pre></td></tr></table></figure></li><li><p>sc(查看已加载的类信息)</p><ul><li>-d 输出当前类的详细信息</li><li>-f 输出当前类的成员变量信息</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sc -d -f kl.cdsm2.web.MainApp<br></code></pre></td></tr></table></figure><ul><li>sm(查看已加载类的方法信息)<ul><li>-d 展示每个方法的详细信息</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sm -d kl.cdsm2.web.MainApp [init]<br></code></pre></td></tr></table></figure><ul><li>dump(已加载的bytecode 到指定目录)</li><li>heapdump(类似于jmap的heap dump功能)</li><li>vmtool(采用JVMTI接口查看内存对象，强制GC)<ul><li>JVMTI接口（<a href="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html%EF%BC%89">https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html）</a></li><li>–action 后接需要指定的命令</li><li>getInstances (-x/–expand) </li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vmtool --action getInstances --className kl.cdsm2.config.ApiServiceCfg -x 3<br></code></pre></td></tr></table></figure><ul><li><p>jad(反编译指定已加载类的源码)</p></li><li><p>classloader(查看类加载信息)</p><ul><li>–load 使用类加载去加载类信息</li><li>-t 查看继承树</li><li>-c 查看URLClassloader实际的urls</li></ul></li><li><p>mc (编译.java 文件生成.class)</p></li><li><p>retransform/redefine(加载外部的.class文件，retransform/redefine jvm已加载的类)</p><ul><li>不允许新增加field/method</li><li>正在跑的函数，没有退出不能生效。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">结合 jad/mc 命令使用<br>jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java<br> <br>mc /tmp/UserController.java -d /tmp<br> <br>retransform /tmp/com/example/demo/arthas/user/UserController.class<br><br>使用mc命令来编译jad的反编译的代码有可能失败。可以在本地修改代码，编译好后再上传到服务器上。有的服务器不允许直接上传文件，可以使用base64命令来绕过。<br><br>在本地先转换.class文件为base64，再保存为result.txt<br><br>base64 &lt; Test.class &gt; result.txt<br>到服务器上，新建并编辑result.txt，复制本地的内容，粘贴再保存<br><br>把服务器上的 result.txt还原为.class<br><br>base64 -d &lt; result.txt &gt; Test.class<br>用md5命令计算哈希值，校验是否一致<br></code></pre></td></tr></table></figure><ul><li><p>monitor(方法执行监控)</p><ul><li>-c 统计周期，默认值为120秒</li></ul></li><li><p>watch(函数执行数据观测)</p><ul><li>-b 函数调用之前观察</li><li>-f 函数调用之后观察</li><li>-s 函数返回之后观察</li><li>-e 函数异常之后观察</li><li>-x 函数深度</li></ul></li><li><p>trace（方法内部调用路径,并输出方法路径上的每个节点上耗时）渲染和统计整个调用链路上的所有性能开销和追踪调用链路</p><ul><li>-n 次数</li><li>–skipJDKMethod false default true</li><li>‘#cost &gt; 10’展示耗时大于10ms的调用路径，有利于排查问题</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">trace kl.cdsm2.service.apisvr.biz.cert.CertIssueApplyHandler handleBiz<br>trace kl.cdsm2.service.apisvr.biz.cert.CertIssueApplyHandler handleBiz &#x27;#cost&gt;10&#x27;<br></code></pre></td></tr></table></figure><ul><li>stack(输出当前方法被调用的调用路径)，使用方法通trace</li><li>tt（方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调进行观测，timetunnel）<ul><li>-t 记录方法每次的指定情况</li><li>-n 3 当你执行一个调用量不高的方法可能你还能有足够的时间用ctrl C 中断，如果遇到调用量非常大的方法，瞬间就把你的JVM内存撑爆。</li><li>-l 查看时空隧道，检索调用记录</li><li>-i index 编号 查看详细信息</li><li>-p 重做一次调用</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tt -t kl.cdsm2.service.apisvr.biz.cert.CertIssueApplyHandler handleBiz<br>tt -l<br>tt -s &#x27;method.name==&quot;handleBiz&quot;&#x27;<br>tt -i 1000 -p<br></code></pre></td></tr></table></figure><ul><li>profiler 支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集的采样结果生成火焰图</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">profiler start<br>profiler status<br>profiler stop --format html<br></code></pre></td></tr></table></figure><ul><li>base64</li><li>tee</li><li>auth</li></ul>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引与数据结构</title>
    <link href="/2021/12/07/mysql%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/12/07/mysql%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是帮助mysql高效获取数据的排好序的数据结构。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
